# 自动打印问题修复报告

## 问题描述
自动打印功能第一次可以正常打单，但当客户再下单时就不会打印出订单了。

## 根本原因分析

### 1. ⚠️ **蓝牙监听器被错误移除** (最关键)

**位置**: `onUnload` 生命周期函数 (原第 2881 行)

**问题代码**:
```javascript
onUnload: function () {
    // ...
    wx.offBLEConnectionStateChange()  // ❌ 没有传入回调函数
    // ...
}
```

**问题详情**:
- `wx.offBLEConnectionStateChange()` 在不传参数时会移除**所有**蓝牙连接监听器
- 这导致在 `setupBluetoothConnectionListener()` 中设置的监听器被意外移除
- 当打印机断开重连时，系统无法检测到连接状态变化
- **结果**: 第二次下单时，打印机虽然还显示连接，但实际连接可能已断开

**修复方案**:
- 保存监听器回调函数的引用
- 在移除时只移除我们设置的那个监听器

### 2. 🔄 **定时器重复启动**

**位置**: `onLoad` 和 `onShow` 生命周期函数

**问题代码**:
```javascript
onLoad: function (options) {
    // ...
    this.startOrderMonitoring()  // 第1次启动
}

onShow: function () {
    // ...
    this.startOrderMonitoring()  // 第2次启动 ❌ 重复了！
    this.startAutoShipping()     // 第2次启动 ❌ 重复了！
}
```

**问题详情**:
- `onLoad` 调用一次，`onShow` 可能被多次调用
- 没有检查定时器是否已存在，导致创建多个定时器
- 只保存最后一个定时器的引用，之前的定时器无法被清除
- **结果**: 多个定时器同时运行，可能导致重复处理订单

**修复方案**:
- 在 `startOrderMonitoring()` 和 `startAutoShipping()` 开头添加重复检查
- 如果定时器已存在，直接返回

### 3. 📊 **订单监听逻辑不准确**

**位置**: `checkNewOrders` 函数

**问题代码**:
```javascript
checkNewOrders() {
    // ...
    if (currentOrderCount > that.data.lastOrderCount) {
        // 有新订单
        const newOrdersCount = currentOrderCount - that.data.lastOrderCount;
        // ...
    }
}
```

**问题详情**:
- 仅使用订单数量比较，无法准确识别哪些是新订单
- 如果旧订单状态变化（如发货），数量变化但不一定有新订单
- **结果**: 可能错误触发或错过新订单通知

**修复方案**:
- 使用订单ID集合而不是简单计数
- 通过对比ID集合准确找出新增的订单

## 修复内容

### ✅ 修复 1: 蓝牙监听器管理

**文件**: `bgManage.js`

```javascript
// 在 onLoad 中初始化
onLoad: function (options) {
    // ...
    // 初始化蓝牙监听器回调引用（用于后续移除）
    this.bluetoothStateChangeHandler = null
    // ...
}

// 改进 setupBluetoothConnectionListener
setupBluetoothConnectionListener() {
    const that = this;
    
    // 如果已经设置过监听器，先移除旧的
    if (that.bluetoothStateChangeHandler) {
        console.log('🔄 移除旧的蓝牙状态监听器');
        wx.offBLEConnectionStateChange(that.bluetoothStateChangeHandler);
    }
    
    // 定义监听器回调函数
    that.bluetoothStateChangeHandler = function(res) {
        console.log('🔌 蓝牙连接状态变化:', res);
        // ... 处理逻辑
    };
    
    // 注册监听器
    wx.onBLEConnectionStateChange(that.bluetoothStateChangeHandler);
    console.log('✅ 蓝牙连接状态监听器已设置');
}

// 在 onUnload 中正确移除
onUnload: function () {
    // ...
    // 正确移除蓝牙连接状态监听器（只移除我们设置的那个）
    if (this.bluetoothStateChangeHandler) {
        console.log('🔌 移除蓝牙连接状态监听器');
        wx.offBLEConnectionStateChange(this.bluetoothStateChangeHandler);
        this.bluetoothStateChangeHandler = null;
        console.log('✅ 蓝牙监听器已移除');
    }
    // ...
}
```

### ✅ 修复 2: 定时器重复启动

**文件**: `bgManage.js`

```javascript
// 开始订单监听
startOrderMonitoring() {
    const that = this;
    
    // 检查是否已经有订单监听定时器在运行
    if (that.data.orderCheckInterval) {
        console.log('⚠️ 订单监听定时器已存在，跳过重复启动');
        return;
    }
    
    console.log('🔔 启动订单监听，每30秒检查一次新订单');
    
    // 每30秒检查一次新订单
    that.data.orderCheckInterval = setInterval(() => {
        that.checkNewOrders();
    }, 30000);
    
    // 初始化订单数量
    that.getInitialOrderCount();
    
    console.log('✅ 订单监听已启动，定时器ID:', that.data.orderCheckInterval);
}

// 启动自动发货检查
startAutoShipping() {
    if (!this.data.autoShippingEnabled) {
        console.log('⚠️ 自动发货功能已禁用')
        return
    }
    
    // 检查是否已经有自动发货定时器在运行
    if (this.data.autoShippingInterval) {
        console.log('⚠️ 自动发货定时器已存在，跳过重复启动');
        return;
    }

    console.log('🚚 启动自动发货检查，每30秒检查一次')
    // ... 其余代码
}
```

### ✅ 修复 3: 订单监听逻辑

**文件**: `bgManage.js`

```javascript
// 获取初始订单数量
getInitialOrderCount() {
    const that = this;
    console.log('📊 获取初始订单数量...');
    
    app.getInfoByOrder('order_master', 'orderTime', 'desc', e => {
        // 使用与检查新订单相同的过滤条件
        const paidOrders = e.data.filter(order => 
            order.paySuccess && 
            !order.sending && 
            (!order.printed || order.printed !== true)
        );
        
        const orderIds = new Set(paidOrders.map(o => o._id));
        
        // 初始化订单ID集合
        that.lastOrderIds = orderIds;
        
        that.setData({
            lastOrderCount: paidOrders.length
        });
        
        console.log(`✅ 初始订单数量: ${paidOrders.length}`);
        console.log(`✅ 初始订单ID集合大小: ${orderIds.size}`);
    });
}

// 检查新订单
checkNewOrders() {
    const that = this;
    console.log('🔍 ===== 开始检查新订单 =====');
    
    app.getInfoByOrder('order_master', 'orderTime', 'desc', e => {
        // 过滤条件：已支付、未发货、未打印的订单
        const paidOrders = e.data.filter(order => 
            order.paySuccess && 
            !order.sending && 
            (!order.printed || order.printed !== true)
        );
        
        const currentOrderCount = paidOrders.length;
        const currentOrderIds = new Set(paidOrders.map(o => o._id));
        
        console.log('🔔[打印调试] 当前可处理订单数量:', currentOrderCount);
        console.log('🔔[打印调试] 上次记录的订单数量:', that.data.lastOrderCount);
        console.log('🔔[打印调试] 可处理订单ID列表(最多10个):', Array.from(currentOrderIds).slice(0, 10));
        
        // 初始化时没有 lastOrderIds，不触发通知
        if (!that.lastOrderIds) {
            console.log('📌 初始化订单ID集合');
            that.lastOrderIds = currentOrderIds;
            that.setData({
                lastOrderCount: currentOrderCount
            });
            return;
        }
        
        // 找出新增的订单（当前ID集合中有，但上次没有）
        const newOrderIds = Array.from(currentOrderIds).filter(id => !that.lastOrderIds.has(id));
        
        if (newOrderIds.length > 0) {
            console.log('🆕[打印调试] 检测到 ' + newOrderIds.length + ' 个新订单:', newOrderIds);
            
            // 找到第一个新订单
            const firstNewOrder = paidOrders.find(o => o._id === newOrderIds[0]);
            that.showNewOrderNotification(newOrderIds.length, firstNewOrder);
            
            // 更新订单ID集合和数量
            that.lastOrderIds = currentOrderIds;
            that.setData({
                lastOrderCount: currentOrderCount
            });
            
            // 刷新订单列表
            that.getAllList();
        } else {
            console.log('✅ 没有新订单');
            // 仍然更新状态，以防订单被删除或状态变化
            that.lastOrderIds = currentOrderIds;
            that.setData({
                lastOrderCount: currentOrderCount
            });
        }
    });
}
```

### ✅ 修复 4: 增强调试日志

在 `executeAutoPrint` 函数中添加了大量详细日志：

```javascript
executeAutoPrint(order, characteristic) {
    console.log(`🤖 ===== 开始执行自动打印 =====`);
    console.log(`📋 订单ID: ${order._id}`);
    console.log(`📋 订单号: ${order.orderNumber || '无'}`);
    console.log(`👤 客户: ${order.name} - ${order.phone}`);
    console.log(`🖨️ 打印机特征值: ${JSON.stringify(characteristic)}`);
    console.log(`🔍 当前打印锁集合大小(本地): ${this.printingOrders.size}`);
    console.log(`🔍 当前打印锁集合大小(全局): ${app.globalData.printingOrders.size}`);
    
    // 检查是否正在打印
    if (this.printingOrders.has(order._id)) {
        console.log(`⚠️ 订单 ${order._id} 已在本地打印锁中，跳过重复自动打印`);
        return;
    }
    
    if (app.globalData.printingOrders.has(order._id)) {
        console.log(`⚠️ 订单 ${order._id} 已在全局打印锁中，跳过重复自动打印`);
        return;
    }
    
    // ... 详细的打印流程日志
    console.log(`🔌 检查蓝牙连接状态...`);
    console.log(`🔌 打印机设备ID: ${characteristic.deviceId}`);
    console.log(`🔌 服务ID: ${characteristic.serviceId}`);
    console.log(`🔌 特征值ID: ${characteristic.characteristicId}`);
    
    // ... 打印成功/失败都有详细日志
}
```

## 测试步骤

### 1. 准备工作

1. **清除旧数据**（如果之前测试过）:
   - 在微信开发者工具中打开"存储" -> "Storage"
   - 清除所有打印机相关的本地存储
   - 或在代码中调用 `clearAllPrinterData()` 函数

2. **连接打印机**:
   - 打开 bgManage 页面
   - 点击"连接打印机"按钮
   - 选择打印机类型（盒饭打印机 或 水果打印机）
   - 扫描并连接对应的蓝牙打印机
   - 确认页面显示"已连接"状态

### 2. 测试第一次自动打印

1. **模拟下单**:
   - 在小程序中下一个订单
   - 完成支付

2. **观察日志**:
   打开微信开发者工具控制台，观察以下日志：
   ```
   🔍 ===== 开始检查新订单 =====
   🆕[打印调试] 检测到 1 个新订单: [订单ID]
   🤖 ===== 开始执行自动打印 =====
   📋 订单ID: xxx
   🔌 检查蓝牙连接状态...
   📄 正在格式化自动打印内容...
   📡 开始发送自动打印数据到打印机...
   ✅ 订单 xxx 自动打印数据发送成功
   🎉 ===== 自动打印成功完成 =====
   📤 开始更新订单 xxx 状态为：已打印 + 已发货
   ✅ 订单 xxx 打印+发货状态已更新
   ```

3. **验证结果**:
   - 打印机应该打印出订单小票
   - 订单状态应该变为"已发货"
   - 页面应该显示订单已从"待发货"移到"已发货"列表

### 3. 测试第二次自动打印（关键！）

1. **再次下单**:
   - 在小程序中再下一个新订单
   - 完成支付

2. **重点观察日志**:
   ```
   🔍 ===== 开始检查新订单 =====
   🔔[打印调试] 当前可处理订单数量: 1
   🔔[打印调试] 上次记录的订单数量: 0
   🆕[打印调试] 检测到 1 个新订单: [新订单ID]
   🤖 ===== 开始执行自动打印 =====
   📋 订单ID: [新订单ID]
   🔍 当前打印锁集合大小(本地): 0
   🔍 当前打印锁集合大小(全局): 0
   🔌 检查蓝牙连接状态...
   🔌 打印机设备ID: xxx
   🔌 蓝牙连接状态变化: {connected: true, deviceId: "xxx"}  ← 重点看这里
   ```

3. **验证结果**:
   - 第二个订单应该能正常打印
   - 如果打印失败，日志会明确显示原因
   - 订单状态应该正确更新

### 4. 压力测试

1. **连续下单**:
   - 连续下3-5个订单
   - 观察每个订单是否都能正常打印

2. **检查日志**:
   - 确认没有"跳过重复自动打印"的警告
   - 确认打印锁能正确加锁和释放
   - 确认蓝牙监听器正常工作

### 5. 页面切换测试

1. **测试场景**:
   - 在 bgManage 页面
   - 切换到其他页面
   - 再切回 bgManage 页面
   - 下新订单

2. **重点观察**:
   ```
   👋 ===== bgManage页面隐藏 =====
   🛑 停止订单监听，清除定时器ID: xxx
   ✅ 订单监听已停止
   
   👀 ===== bgManage页面显示 =====
   🔔 启动订单监听，每30秒检查一次新订单
   ⚠️ 订单监听定时器已存在，跳过重复启动  ← 不应该出现（因为隐藏时已停止）
   ✅ 订单监听已启动，定时器ID: xxx
   ```

3. **验证**:
   - 定时器应该能正确停止和重启
   - 不应该有重复的定时器
   - 新订单仍能正常打印

## 可能的问题和解决方案

### 问题 1: 第二次仍然不打印

**可能原因**:
1. 打印机真的断开了连接
2. 打印机缓冲区满了

**调试步骤**:
1. 查看日志中的 `🔌 蓝牙连接状态变化` 消息
2. 如果看到 `{connected: false}`，说明打印机断开了
3. 尝试重新连接打印机

**解决方法**:
```javascript
// 在日志中看到断开连接后，手动重连：
1. 点击"断开打印机"
2. 重新扫描并连接
3. 再次测试
```

### 问题 2: 出现"跳过重复自动打印"警告

**可能原因**:
打印锁没有正确释放

**调试步骤**:
1. 查看日志中的打印锁大小
2. 确认打印成功或失败后，锁是否被释放

**解决方法**:
如果锁一直没有释放，可能是打印过程卡住了。重启小程序并重新连接打印机。

### 问题 3: 定时器重复运行

**症状**:
日志中出现多次相同的检查新订单日志

**解决方法**:
重启小程序，问题应该已被修复。

## 日志说明

修复后的代码包含以下日志前缀，便于调试：

- 🚀 页面生命周期
- 🔔 订单监听
- 🤖 自动打印
- 🔌 蓝牙连接
- 🔒 打印锁
- ✅ 成功操作
- ❌ 失败操作
- ⚠️ 警告信息
- 📋 订单信息
- 🔍 调试检查

## 总结

这次修复解决了三个核心问题：

1. **蓝牙监听器被错误移除** - 这是导致第二次不打印的主要原因
2. **定时器重复启动** - 可能导致订单被重复处理或遗漏
3. **订单监听逻辑不准确** - 改用ID集合比较，更加可靠

所有修改都添加了详细的日志输出，便于后续排查问题。

## 建议

1. **测试环境**: 先在开发环境充分测试，确认修复有效
2. **日志监控**: 上线后注意监控日志，特别是打印失败的情况
3. **用户反馈**: 收集用户关于自动打印的反馈
4. **定期检查**: 定期检查蓝牙打印机的连接状态
5. **数据库备份**: 在大规模使用前，先备份数据库
